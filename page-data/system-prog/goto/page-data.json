{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/system-prog/goto/","result":{"data":{"site":{"siteMetadata":{"title":"monognuisy blog."}},"markdownRemark":{"id":"baa0637c-e96a-51ab-85ba-73f885e13f21","excerpt":"🤔 goto? 많은 C 입문 교재를 보면 goto를 마치 '절대로 쓰면 안되는 것' 이라던지, '한 번이라도 쓰면 큰일이 나는 것' 과 같이 취급한다.\n컴퓨터 과학에 지대한 영향을 끼친 에츠허르 다익스트라(Edsger W. Dijkstra) 옹께서 goto…","html":"<h2>🤔 goto?</h2>\n<p>많은 C 입문 교재를 보면 goto를 마치 '절대로 쓰면 안되는 것' 이라던지, '한 번이라도 쓰면 큰일이 나는 것' 과 같이 취급한다.\n컴퓨터 과학에 지대한 영향을 끼친 에츠허르 다익스트라(Edsger W. Dijkstra) 옹께서 <code>goto</code>를 절대로 쓰지 말라고 한 것의 영향이\n크다고 생각한다.</p>\n<p>그렇다면, 왜 쓰지 말아야 할까?</p>\n<h3>🤦‍♂️ 굳이 쓸 필요가 없음</h3>\n<p>다음 두 코드는 완벽히 동일하게 작동한다. 어느 것이 더 깔끔한가?</p>\n<deckgo-highlight-code language=\"c\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">int sumTo(int N) {\n    int res = 0;\n\n    for (int i = 1; i &lt;= N; i++) {\n        res += i;\n    }\n\n    return res;\n}</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"c\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">int sumTo(int N) {\n    int res = 0;\n    int i = 1;\n\n    if (i &gt; N) goto done;\n\nloop:\n    res += i;\n    i++;\n    if (i &lt;= N) goto loop;\n\ndone:\n    return res;\n}</code>\n        </deckgo-highlight-code>\n<p>당연히 위의 <code>for</code> 문이 더 간결하고 깔끔해 보인다. <code>goto</code>문을 쓴 코드는 마치 어셈블리어 같다.</p>\n<p>(최대한 단순히 logic만 표현하였다.)</p>\n<deckgo-highlight-code language=\"asmatmel\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">.sumTo\n    pushq   %rbx\n    movl    $0, %eax\n    movl    $1, %ebx\n    cmp     %rdi, %rbx\n    jg      .DONE\n.LOOP\n    addq    %rbx, %rax\n    addq    $1, %rbx\n    cmp     %rdi, %rbx\n    jle     .LOOP\n.DONE\n    popq    %rbx\n    ret</code>\n        </deckgo-highlight-code>\n<p>이렇게, 굳이 어셈블리어로 쓰기 위한 것이 아닌 이상, goto 문은 대부분 <code>if</code>와 같은 조건문과 <code>while</code>, <code>for</code>과 같은 반복문으로 <strong>대체</strong>될 수 있다.</p>\n<h3>🤮 스파게티 코드?</h3>\n<p>또한, <code>goto</code>를 남용하면 흔히 말하는 <strong>스파게티 코드</strong>가 나올 수 있다. 만드는 법은 어렵지 않다. 다만, 해석하기 힘들 뿐.</p>\n<deckgo-highlight-code language=\"c\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">#include &lt;stdio.h&gt;\n\nint main() {\n    int x = 1, y = 3, z = 4;\n    goto L2;\n\nL1:\n    if (++x &amp; 1) goto end;\n\nL3:\n    z -= 3;\n    goto L2;\n    y--;\n\nL2:\n    x += z++;\n\n    if (z &amp; 1) goto L1;\n\n    goto L3;\n\nend:\n    printf(&quot;%d, %d, %d\\n&quot;, x, y, z);\n    return 0;\n}</code>\n        </deckgo-highlight-code>\n<p>(이게 바로 예상이 된다면... <code>goto</code>를 마음껏 써도 좋다. 물론 혼자만.)</p>\n<p>이렇게 <code>goto</code>를 쓸데없이 남발하면, 보기도 싫고, 해석하기도 힘들고, 건들기는 더욱 두려운 코드가 만들어진다. <br>\n그럼, 정말로 <code>goto</code>는 '절대로 쓰면 안되는 것'일까?</p>\n<h3>👍 다중 반복문의 탈출</h3>\n<p>의외로, 좋은 사용처가 있다. 바로, <strong>다중 반복문</strong>(nested loop)의 탈출이다. <br>\n이를 위해 간단한 C-like pseudo code를 작성하면 다음과 같다.</p>\n<deckgo-highlight-code language=\"c\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">// do something...\nfor (int i = ...) {\n    for (int j = ...) {\n        for (int k = ...) {\n            // nested for문 전체를 break 해버리고 싶음!\n            goto out;\n        }\n    }\n}\n\nout:\n// nice break. do something...</code>\n        </deckgo-highlight-code>\n<p>오히려 이런 경우에는 <code>goto</code>를 사용하지 않으면 복잡해진다. <code>goto</code>를 안쓰면 flag 변수를 여러개 만들어서 매번 검사하고 탈출해야 하는데,\n만일 이러한 flag 변수가 일회용이라면, 이는 크게 비효율적일 것이다.</p>\n<deckgo-highlight-code language=\"c\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">// do something...\nint flag1 = 0;\nfor (int i = ...) {\n    int flag2 = 0;\n    for (int j = ...) {\n        int flag3 = 0;\n        for (int k = ...) {\n            // nested for문 전체를 break 해버리고 싶음!\n            flag1 = flag2 = flag3 = 1;\n            if (flag3) break;\n        }\n        if (flag2) break;\n    }\n    if (flag1) break;\n}\n\n// 이 얼마나 비효율적인가!</code>\n        </deckgo-highlight-code>\n<p>물론, flag 변수가 많이 사용되는 것은 비트마스킹을 통해 어느정도 해결할 수 있다. 그럼에도 불구하고, 저 <code>if</code>문은 어쩔 수 없다.</p>\n<p>따라서, 다중 반복문에서는 <code>goto</code>를 사용하는 것이 가독성이나 확장성 측면에서 좋다고 할 수 있다.</p>\n<h3>🙂 간단한 예외처리</h3>\n<p>예외처리에서도 <code>goto</code>는 많이 사용된다.</p>\n<deckgo-highlight-code language=\"c\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">// in _cpu_down:\n\nif (st-&gt;state &gt; CPUHP_TEARDOWN_CPU) {\n    st-&gt;target = max((int)target, CPUHP_TEARDOWN_CPU);\n    ret = cpuhp_kick_ap_work(cpu);\n\n    if (ret)\n        goto out;\n\n    if (st-&gt;state &gt; CPUHP_TEARDOWN_CPU)\n        goto out;\n\n    st-&gt;target = target;\n}\n\nret = cpuhp_down_callbacks(cpu, st, target);\nif (ret &amp;&amp; st-&gt;state &lt; prev_state) {\n    if (st-&gt;state == CPUHP_TEARDOWN_CPU) {\n        cpuhp_reset_state(cpu, st, prev_state);\n        __cpuhp_kick_ap(st);\n    } else {\n        WARN(1, &quot;DEAD callback error for CPU%d&quot;, cpu);\n    }\n}\n\nout:\n    cpus_write_unlock();\n    lockup_detector_cleanup();\n    arch_smt_update();\n    cpu_up_down_serialize_trainwrecks(tasks_frozen);\n    return ret;</code>\n        </deckgo-highlight-code>\n<p>source: <a href=\"https://github.com/torvalds/linux/blob/master/kernel/cpu.c\">https://github.com/torvalds/linux/blob/master/kernel/cpu.c</a></p>\n<p>이는 linux kernel의 cpu.c 코드에서 에러 처리를 위하여 <code>goto</code>를 사용한 모습이다. <br>\n오류를 발생하는 <code>ret</code> 변수는 <code>_cpu_down</code> 함수 내에서 할당되고, 처리된다.</p>\n<p>따라서, 어떠한 <strong>함수 내에서 예외를 처리할 수 있다면</strong>, <code>goto</code>문을 사용하는 것이 확실하고, 깔끔한 방법 중 하나라는 것을 확인할 수 있다.</p>\n<h3>😒 그러면 goto는 어디로든 점프할 수 있나요?</h3>\n<p><strong>아니다</strong>. 이것이 <code>goto</code>의 한계라고 할 수 있다. <code>goto</code>는 일반적으로 한 함수 안에서만 점프할 수 있다. 즉, 다음과 같은 코드는 컴파일 오류를 발생시킨다.</p>\n<deckgo-highlight-code language=\"c\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">void foo() {\n    bar();\nL1:               // useless\n    return;\n}\n\nvoid bar() {\n    goto L1;\n    // 이 함수에는 L1이 없는데?\n}\n\nint main() {\n    foo();\n    return 0;\n}</code>\n        </deckgo-highlight-code>\n<p>이렇게 여러 함수를 옮겨다니기 위해서는 non-local jump인 <code>setjmp</code>와 <code>longjmp</code>를 사용해야만 한다.</p>\n<p>즉, <code>goto</code>로 예외를 처리하기 위해서는 꼭 그 함수 내에서 (다른 errorful한 함수를 호출하지 않고) 처리할 수 있을 정도로 단순한 예외여야 한다. <br>\n(물론 nonlocal jump를 쓰더라도 메모리 해제 등등 생각해야 할 것이 많다.)</p>\n<h3>결론 및 세줄요약</h3>\n<p><code>goto</code>는 마냥 나쁜것은 아니다. 대부분의 상황에서는 코드를 지저분하게 만들지만, 특정한 상황에서는 오히려 코드를 보기 좋게 만들 수 있다.\n따라서, 적재적소에 쓰면서 코드를 짤 필요가 있다.</p>\n<ol>\n<li>웬만해선 <code>goto</code>는 <code>if</code>나 <code>for</code>로 대체될 수 있다.</li>\n<li>다중 반복문이나 간단한 예외처리에서는 <code>goto</code>가 더 좋을수도?</li>\n<li>근데 non-local jump는 안됨.</li>\n</ol>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#-goto\">🤔 goto?</a></p>\n<ul>\n<li><a href=\"#%EF%B8%8F-%EA%B5%B3%EC%9D%B4-%EC%93%B8-%ED%95%84%EC%9A%94%EA%B0%80-%EC%97%86%EC%9D%8C\">🤦‍♂️ 굳이 쓸 필요가 없음</a></li>\n<li><a href=\"#-%EC%8A%A4%ED%8C%8C%EA%B2%8C%ED%8B%B0-%EC%BD%94%EB%93%9C\">🤮 스파게티 코드?</a></li>\n<li><a href=\"#-%EB%8B%A4%EC%A4%91-%EB%B0%98%EB%B3%B5%EB%AC%B8%EC%9D%98-%ED%83%88%EC%B6%9C\">👍 다중 반복문의 탈출</a></li>\n<li><a href=\"#-%EA%B0%84%EB%8B%A8%ED%95%9C-%EC%98%88%EC%99%B8%EC%B2%98%EB%A6%AC\">🙂 간단한 예외처리</a></li>\n<li><a href=\"#-%EA%B7%B8%EB%9F%AC%EB%A9%B4-goto%EB%8A%94-%EC%96%B4%EB%94%94%EB%A1%9C%EB%93%A0-%EC%A0%90%ED%94%84%ED%95%A0-%EC%88%98-%EC%9E%88%EB%82%98%EC%9A%94\">😒 그러면 goto는 어디로든 점프할 수 있나요?</a></li>\n<li><a href=\"#%EA%B2%B0%EB%A1%A0-%EB%B0%8F-%EC%84%B8%EC%A4%84%EC%9A%94%EC%95%BD\">결론 및 세줄요약</a></li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"C에서의 goto","date":"December 11, 2022","description":"과연 정말로 쓰면 안되는 것일까?","tags":["System Programming","Programming"]}},"previous":{"fields":{"slug":"/ai/1/"},"frontmatter":{"title":"Differentiation w.r.t. Vector / Matrix"}},"next":null},"pageContext":{"id":"baa0637c-e96a-51ab-85ba-73f885e13f21","previousPostId":"93bd4dbb-e769-5a8a-b249-45a8cc42a86b","nextPostId":null}},"staticQueryHashes":["2841359383","3274528899"]}