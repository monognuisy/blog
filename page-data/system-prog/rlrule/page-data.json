{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/system-prog/rlrule/","result":{"data":{"site":{"siteMetadata":{"title":"monognuisy blog."}},"markdownRemark":{"id":"cd7bab91-e858-52fa-a9ce-b271b44bb618","excerpt":"C Right-Left Rule (Rick Ord's CSE 30 - UC San Diego)\n를 참고하였습니다. Right to Left rule C는 type이 굉장히 복잡한 언어이다. 이는 포인터(pointer), 배열(array), 함수(function…","html":"<p><a href=\"https://cseweb.ucsd.edu//~ricko/rt_lt.rule.html\">C Right-Left Rule (Rick Ord's CSE 30 - UC San Diego)</a>\n를 참고하였습니다.</p>\n<h2>Right to Left rule</h2>\n<p>C는 type이 굉장히 복잡한 언어이다. 이는 포인터(pointer), 배열(array), 함수(function)의 합작의 결과인데, 이들이 섞이는 순간 미치게 된다. 예를들어, 다음과 같은 <strong>선언</strong>(Declaration)을 쉽게 해석할 수 있겠는가?</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>fp1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div style=\"text-align: center\">\n    <img src=\"https://i.imgur.com/QCLmqNn_d.webp?maxwidth=760&fidelity=grand\" alt=\"비추\">\n</div>\n<p>쉽지 않다. 저것이 함수 포인터인지, 배열에 대한 포인터인지, 뭔가 많이 섞였는데 어느 순서로 섞였는지 쉽게 파악이 안된다. 그래서, 이를 복호화(decipher) 하는 과정이 필요한데, 이를 Right to Left(이하 RL) rule 이라고 한다.</p>\n<h3>준비</h3>\n<p>앞으로는 영어를 사용하자(??). RL rule은 영어권 사용자를 위해 만들어진 방법으로, 어순이 반대인 한국어로는 이해하기 어렵다. 즉, 한국어 사용자는 다음과 같은 과정을 거쳐야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\">암호같은 C 변수 선언문 <span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">></span> RL을 사용하여 영어로 복호화 <span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">></span> 그 영문장을 한국어로 번역<span class=\"token operator\">!</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>영문장을 한국어로 번역하는 과정은 그리 어렵지 않다. 그러면, RL rule에 대해 알아보자.</p>\n<h3>RL rule</h3>\n<p>변수의 선언에서 다음 기호를 <strong>만나면</strong>, 아래에 표시된 대로 읽는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token operator\">*</span>            <span class=\"token string\">\"pointer to\"</span>                 번역하면 <span class=\"token string\">\"~의 포인터\"</span>\n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>           <span class=\"token string\">\"array of\"</span>                   번역하면 <span class=\"token string\">\"~의 배열\"</span>\n<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>           <span class=\"token string\">\"function returning\"</span>         번역하면 <span class=\"token string\">\"~를 반환하는 함수\"</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>일단은 영어로 읽기로 하자. 그럼, 어떻게 기호를 <strong>만날까</strong>? <br>\n다음과 같은 순서를 따른다.</p>\n<ol>\n<li>\n<p><span style=\"background-color: #aff0ef; padding: 3px; border-radius: 3px\"><strong>식별자</strong>를 찾는다.</span></p>\n<p>식별자(identifier)는 변수의 이름으로, 유일하다. 여기가 출발점이다. 그러면, 문장을 다음과 같이 시작하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\">식별자 is <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n</li>\n<li>\n<p><span style=\"background-color: #aff0ef; padding: 3px; border-radius: 3px\"><strong>오른쪽으로 이동!</strong></span></p>\n<ul>\n<li>식별자로부터 오른쪽으로 이동할 수 있을 때까지 오른쪽으로 이동하면서 기호를 읽는다. 즉, 만일 식별자 오른쪽에 <code class=\"language-text\">[]</code>가 있다면 <code class=\"language-text\">식별자 is array of ...</code> 으로 읽으면 된다.</li>\n<li>만일, <code class=\"language-text\">(</code>를 만난다면, 그것은 <code class=\"language-text\">()</code>의 일부분일 것이다. 즉, <code class=\"language-text\">()</code> 전체를 <code class=\"language-text\">식별자 is function returning ...</code> 이라고 읽고 넘어가면 된다.</li>\n<li>하지만, <code class=\"language-text\">(</code> 를 만나지 않고 <code class=\"language-text\">)</code> 만 만난다면, 그것은 함수의 괄호가 아닌 다른 괄호의 닫는 괄호이다. 즉, 오른쪽으로 이동하는 것을 <strong>멈춰야 한다</strong>.</li>\n</ul>\n</li>\n<li>\n<p><span style=\"background-color: #aff0ef; padding: 3px; border-radius: 3px\"><strong>왼쪽으로 이동!</strong></span></p>\n<ul>\n<li>오른쪽으로 가기를 멈췄다면, 식별자로부터 왼쪽으로 이동할 수 있을 때까지 왼쪽으로 이동하면서 기호를 읽는다. 즉, 왼쪽에 <code class=\"language-text\">*</code>가 있다면 <code class=\"language-text\">식별자 is pointer to ...</code> 으로 읽으면 된다.</li>\n<li><code class=\"language-text\">(</code> 는 여는 괄호이므로, 만난다면 멈춘다.</li>\n<li>만일 멈춘 후, 오른쪽으로 갈 수 있다면 다시 오른쪽으로 간다 (오른쪽 가다가 멈췄던 곳 부터).</li>\n</ul>\n</li>\n</ol>\n<h3>예시</h3>\n<p>간단하게, 다음을 읽어보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>p<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>(배열 포인터인지 포인터 배열인지 헷갈린다면, 꼭 아래의 해설을 천천히 따라가보자!)</p>\n<ol>\n<li>\n<p><strong>식별자 찾기</strong></p>\n<p>식별자는 <code class=\"language-text\">p</code>이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>p<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n     <span class=\"token operator\">^</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>즉, <code class=\"language-text\">“<strong>p is</strong>”</code></p>\n</li>\n<li>\n<p><strong>오른쪽으로 이동!</strong></p>\n<ol>\n<li>\n<p>오른쪽으로 이동한다. <code class=\"language-text\">[]</code>가 보인다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>p<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      <span class=\"token operator\">^</span><span class=\"token operator\">^</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>즉, <code class=\"language-text\">“p is <strong>array of</strong>”</code></p>\n</li>\n<li>\n<p>더 이상 오른쪽으로 갈 수 없다. (세미콜론이 있기 때문) 따라서 멈추고, 다음 단계를 따른다.</p>\n</li>\n</ol>\n</li>\n<li>\n<p><strong>왼쪽으로 이동!</strong></p>\n<ol>\n<li>\n<p>왼쪽으로 이동한다. <code class=\"language-text\">*</code>가 보인다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>p<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token operator\">^</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>즉, <code class=\"language-text\">“p is array of <strong>pointer to</strong>”</code></p>\n</li>\n<li>\n<p>왼쪽으로 이동한다. <code class=\"language-text\">int</code>가 보인다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>p<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token operator\">^</span><span class=\"token operator\">^</span><span class=\"token operator\">^</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>즉, <code class=\"language-text\">“p is array of pointer to <strong>int</strong>”</code></p>\n</li>\n<li>\n<p>더 이상 왼쪽으로 이동할 수 없고, 오른쪽으로도 갈 수 없다. 종료.</p>\n</li>\n</ol>\n</li>\n</ol>\n<p>즉, 답은 <code class=\"language-text\">p is array of pointer to int</code> 가 된다. 쉽지 않은가?</p>\n<p>조금 더 복잡한 예제를 풀어보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<ol>\n<li>\n<p><strong>식별자 찾기</strong></p>\n<p>식별자는 <code class=\"language-text\">func</code> 이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n       <span class=\"token operator\">^</span><span class=\"token operator\">^</span><span class=\"token operator\">^</span><span class=\"token operator\">^</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>즉, <code class=\"language-text\">“<strong>func is</strong>”</code></p>\n</li>\n<li>\n<p><strong>오른쪽으로 이동!</strong></p>\n<ol>\n<li>\n<p>한 번 이동하면 <code class=\"language-text\">()</code>가 나온다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n           <span class=\"token operator\">^</span><span class=\"token operator\">^</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>즉, <code class=\"language-text\">“func is <strong>function returning</strong>”</code></p>\n</li>\n<li>\n<p>오른쪽이 닫는 괄호 <code class=\"language-text\">)</code> 로 막혀있다. 즉, 왼쪽으로 이동한다.</p>\n</li>\n</ol>\n</li>\n<li>\n<p><strong>왼쪽으로 이동!</strong></p>\n<ol>\n<li>\n<p>식별자 왼쪽에 <code class=\"language-text\">*</code>가 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token operator\">^</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>즉, <code class=\"language-text\">“func is function returning <strong>pointer to</strong>”</code></p>\n</li>\n<li>\n<p>왼쪽이 여는 괄호 <code class=\"language-text\">(</code> 로 막혀있다. 따라서 다시 오른쪽으로 간다.</p>\n</li>\n</ol>\n</li>\n<li>\n<p><strong>오른쪽으로 이동!</strong></p>\n<ol>\n<li>\n<p>앞서 멈춘 쪽에서 오른쪽으로 가면 <code class=\"language-text\">()</code>가 나온다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              <span class=\"token operator\">^</span><span class=\"token operator\">^</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>즉, <code class=\"language-text\">“func is function returning pointer to <strong>function returning</strong>”</code></p>\n</li>\n<li>\n<p><code class=\"language-text\">;</code>에 의해 막히므로 다시 왼쪽으로 간다.</p>\n</li>\n</ol>\n</li>\n<li>\n<p><strong>왼쪽으로 이동!</strong></p>\n<ol>\n<li>\n<p>앞서 멈춘 쪽에서 왼쪽으로 가면 <code class=\"language-text\">*</code>가 나온다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token operator\">^</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>즉, <code class=\"language-text\">“func is function returning pointer to function returning <strong>pointer to</strong>”</code></p>\n</li>\n<li>\n<p>한번 더 가면 <code class=\"language-text\">int</code>가 나온다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token operator\">^</span><span class=\"token operator\">^</span><span class=\"token operator\">^</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>즉, <code class=\"language-text\">“func is function returning pointer to function returning pointer to <strong>int</strong>”</code></p>\n</li>\n<li>\n<p>더이상 갈 수 없으므로 종료.</p>\n</li>\n</ol>\n</li>\n</ol>\n<p>따라서 답은 <code class=\"language-text\">“func is function returning pointer to function returning pointer to int”</code> 이다. <br>\n복잡하지만, 충분히 할만한 작업이다.</p>\n<p>만일 배열의 크기가 주어진다면, (<code class=\"language-text\">[3]</code>과 같이) <code class=\"language-text\">“array (size 3) of ...”</code> 과 같이 해석하면 될 것이고, <br>\n함수의 매개변수가 주어진다면, (<code class=\"language-text\">(char *, int)</code>와 같이)\n<code class=\"language-text\">“function expecting (char *, int) returning ...”</code> 으로 해석하면 될 것이다.</p>\n<h3>번역</h3>\n<p>어렵지 않다. 영어니까 뒤에서부터 해석하면 되는 것이다. 즉,</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>p<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>는 <code class=\"language-text\">“p is array of pointer to int”</code> 이므로, <code class=\"language-text\">“p는 int의 포인터의 배열이다”</code> 라고 말하면 된다.</p>\n<p>마찬가지로</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>는 <code class=\"language-text\">“func is function returning pointer to function returning pointer to int”</code> 이므로,\n<code class=\"language-text\">”func는 int의 포인터를 반환하는 함수의 포인터를 반환하는 함수”</code> 가 된다.</p>\n<p>그렇다면, 맨 처음 나온 이것은?</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>fp1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><code class=\"language-text\">“fp1 is pointer to function expecting (int) returning pointer to array (size 10) of pointer to int”</code></p>\n<p>번역하면,\n<code class=\"language-text\">“fp1은 int의 포인터의 (크기가 10인) 배열의 포인터를 반환하는 (int를 매개변수로 가지는) 함수의 포인터”</code></p>\n<div style=\"text-align: center\">\n    <img src=\"https://i.imgur.com/e2WKQso.png\" alt=\"으아앙\">\n</div>\n<h3>주의!</h3>\n<h4>다른 것은 다르다.</h4>\n<p>일단, 이 해석 방법에서는 포인터, 배열, 함수를 <strong>다르게</strong> 보고 있다. 즉, 배열 == 포인터나, 함수 == 포인터 이렇게 생각하면 절대로 안된다는 것이다.</p>\n<p>일단 RL로 해석한 다음, 그 뒤에 나름의 논리와 주관을 섞어서 같게 봐야 한다.</p>\n<h4>되는 것과 되지 않는 것</h4>\n<p>다음과 같은 것은 C에서 허용하지 않는다.</p>\n<ul>\n<li><code class=\"language-text\">[]()</code>\n<ul>\n<li>array of function</li>\n</ul>\n</li>\n<li><code class=\"language-text\">()()</code>\n<ul>\n<li>function returning function</li>\n</ul>\n</li>\n<li><code class=\"language-text\">()[]</code>\n<ul>\n<li>function returning array of …</li>\n<li>즉, 배열을 반환할 수는 없다는 것.</li>\n</ul>\n</li>\n</ul>\n<h2>typedef와의 관계</h2>\n<p>이렇게 이상한 변수의 선언을 읽는 방법을 알아봤다. 이는 사실 <code class=\"language-text\">typedef</code>를 해석하는 데에도 유용하다.</p>\n<p>아마 대다수의 책에서 typedef에 대해 잘못 설명한다. 다음과 같이 말이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token operator\">&lt;</span>원래 타입<span class=\"token operator\">></span> <span class=\"token operator\">&lt;</span>새로운 타입<span class=\"token operator\">></span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이는 <code class=\"language-text\">typedef int pid_t;</code> 와 같이 맞는 것 같지만, 사실 그렇지 않다는 것은 다음만 봐도 알 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">char</span> u24<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>(?? 이게 뭐임)</p>\n<p>이렇게 보면 함수 포인터의 <code class=\"language-text\">typedef</code>도 이상하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token class-name\">sighandler_t</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<h3>올바른 설명</h3>\n<p><code class=\"language-text\">typedef</code>에 대한 올바른 설명은 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token operator\">&lt;</span>타입의 선언<span class=\"token operator\">></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>여기서, <strong>타입의 선언</strong>이라는 것은 <strong>식별자(identifier)로 새로운 타입</strong>이 온다는 것이다.</p>\n<p>식별자가 타입이 되었다는 것을 제외하면, 앞서 봤던 변수의 선언과 별 다를 것이 없다. 예를 들어서 다음을 해석해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token class-name\">sighandler_t</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>똑같이 RL rule을 적용하면,</p>\n<p><code class=\"language-text\">“sighandler_t is pointer to function expecting (int) returning void“</code></p>\n<p>대신, 중간에 이것이 <strong>타입</strong>이라는 것을 알려주는 말을 넣으면 된다.</p>\n<p><code class=\"language-text\">“sighandler_t is <strong>type which is</strong> pointer to function expecting (int) returning void“</code></p>\n<p>한국어로 번역하면,</p>\n<p><code class=\"language-text\">“sighandler_t는 void를 반환하는 (int를 매개변수로 하는) 함수의 포인터<strong>를 나타내는 타입이다</strong>”</code></p>\n<p>라고 할 수 있겠다.</p>\n<p>마찬가지로</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">char</span> u24<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>은 다음과 같다.</p>\n<p><code class=\"language-text\">“u24 is type which is array (size 3) of char”</code></p>\n<p>즉, <code class=\"language-text\">“u24는 char의 (크기가 3인) 배열을 나타내는 타입이다”</code></p>\n<h4>아니 이런게 어디에 쓰임…</h4>\n<p>실제로 쓰인다. glibc의 <code class=\"language-text\">setjmp.h</code> 를 살펴보면 다음과 같은 구절(?)이 있다.</p>\n<p><a href=\"https://sites.uclouvain.be/SystInfo/usr/include/setjmp.h.html\">setjmp.h</a></p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">__jmp_buf_tag</span> jmp_buf<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>즉, nonlocal jump시 필요한 type인 <code class=\"language-text\">jmp_buf</code>는 사실, <code class=\"language-text\">“구조체 __jmp_buf_tag의 (크기가 1인) 배열”</code> 이다. 따라서, <code class=\"language-text\">setjmp</code>시에 인자로 <code class=\"language-text\">&amp;jmp_buf</code>가 아닌, 그냥 <code class=\"language-text\">jmp_buf</code> 를 넘겨주어도 되는 것이다.</p>\n<h3>오…</h3>\n<p>이렇게 보면 <code class=\"language-text\">typedef</code>, 괜찮지 않은가? RL rule만 완벽히 터득하면 오히려 직관적이라는 느낌까지 든다.</p>\n<p>근데, 이렇게 선언과 동일한 문법을 쓸 것이면, <code class=\"language-text\">typedec</code>로 이름을 지었으면 더 좋았을 것이라는 생각이 든다.</p>\n<h2>또 다른 팁</h2>\n<p>사실 이 RL rule은 constant pointer 등의 해석에도 도움이 된다. 다음의 예시를 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>p<span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><code class=\"language-text\">“p is pointer to const int”</code></p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">const</span> p<span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><code class=\"language-text\">“p is constant pointer to int”</code></p>\n<p>ㅇㅎ이</p>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#right-to-left-rule\">Right to Left rule</a></p>\n<ul>\n<li>\n<p><a href=\"#%EC%A4%80%EB%B9%84\">준비</a></p>\n</li>\n<li>\n<p><a href=\"#rl-rule\">RL rule</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%98%88%EC%8B%9C\">예시</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%B2%88%EC%97%AD\">번역</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%A3%BC%EC%9D%98\">주의!</a></p>\n<ul>\n<li><a href=\"#%EB%8B%A4%EB%A5%B8-%EA%B2%83%EC%9D%80-%EB%8B%A4%EB%A5%B4%EB%8B%A4\">다른 것은 다르다.</a></li>\n<li><a href=\"#%EB%90%98%EB%8A%94-%EA%B2%83%EA%B3%BC-%EB%90%98%EC%A7%80-%EC%95%8A%EB%8A%94-%EA%B2%83\">되는 것과 되지 않는 것</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#typedef%EC%99%80%EC%9D%98-%EA%B4%80%EA%B3%84\">typedef와의 관계</a></p>\n<ul>\n<li>\n<p><a href=\"#%EC%98%AC%EB%B0%94%EB%A5%B8-%EC%84%A4%EB%AA%85\">올바른 설명</a></p>\n<ul>\n<li><a href=\"#%EC%95%84%EB%8B%88-%EC%9D%B4%EB%9F%B0%EA%B2%8C-%EC%96%B4%EB%94%94%EC%97%90-%EC%93%B0%EC%9E%84\">아니 이런게 어디에 쓰임…</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%98%A4\">오…</a></p>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%98%90-%EB%8B%A4%EB%A5%B8-%ED%8C%81\">또 다른 팁</a></p>\n</li>\n</ul>","frontmatter":{"title":"Right-to-Left Rule과 typedef","date":"February 08, 2023","description":"C에서 복잡한 선언을 해석하는 방법을 알아보자.","tags":["System Programming","Programming"]}},"previous":{"fields":{"slug":"/system-prog/goto/"},"frontmatter":{"title":"C에서의 goto"}},"next":null},"pageContext":{"id":"cd7bab91-e858-52fa-a9ce-b271b44bb618","previousPostId":"baa0637c-e96a-51ab-85ba-73f885e13f21","nextPostId":null}},"staticQueryHashes":["2841359383","3274528899"]}